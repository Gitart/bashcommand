# Трубы и фильтры

> ## обзор
>
> **Обучение:** 25 мин.
> **Упражнения:** 10 мин.
>
> **Вопросов**
>
> *   Как я могу объединить существующие команды, чтобы сделать что\-то новое?
>
>
> **Цели**
>
> *   Перенаправить вывод команды в файл.
>
> *   Обработайте файл вместо ввода с клавиатуры, используя перенаправление.
>
> *   Построить командные конвейеры с двумя или более этапами.
>
> *   Объясните, что обычно происходит, если программе или конвейеру не дано никакого ввода для обработки.
>
> *   Объясните философию Unix «мелкие, слабо соединенные»
>

Теперь, когда мы знаем несколько основных команд, мы наконец\-то можем взглянуть на самую мощную функцию оболочки: простота, с которой она позволяет нам комбинировать существующие программы новыми способами. Мы начнем с каталога, `molecules` который содержит шесть файлов, описывающих некоторые простые органические молекулы. `.pdb` Расширение указывает на то, что эти файлы находятся в Protein формате банк данных в простом текстовом формате , который определяет тип и положение каждого атома в молекуле.

```
$ ls molecules

```

```
cubane.pdb    ethane.pdb    methane.pdb
octane.pdb    pentane.pdb   propane.pdb

```

Давайте перейдем в этот каталог `cd` и запустим команду `wc cubane.pdb` :

```
$ cd molecules
$ wc cubane.pdb

```

```
20  156 1158 cubane.pdb

```

`wc` является командой «подсчета слов»: она подсчитывает количество строк, слов и символов в файлах (слева направо в указанном порядке).

Если мы запустим команду `wc *.pdb` , `*` in будет `*.pdb` соответствовать нулю или более символов, поэтому оболочка превратится `*.pdb` в список всех `.pdb` файлов в текущем каталоге:

```
$ wc *.pdb

```

```
  20  156  1158  cubane.pdb
  12  84   622   ethane.pdb
   9  57   422   methane.pdb
  30  246  1828  octane.pdb
  21  165  1226  pentane.pdb
  15  111  825   propane.pdb
 107  819  6081  total

```

Обратите внимание, что `wc *.pdb` также показывает общее количество всех строк в последней строке вывода.

Если мы запустим `wc -l` вместо just `wc` , в выводе будет показано только количество строк в файле:

```
$ wc -l *.pdb

```

```
  20  cubane.pdb
  12  ethane.pdb
   9  methane.pdb
  30  octane.pdb
  21  pentane.pdb
  15  propane.pdb
 107  total

```

`-c` И `-w` опции также можно использовать с `wc` командой, чтобы показать только количество символов или количество слов в файлах.

> ## Почему он ничего не делает?
>
> Что произойдет, если команда должна обработать файл, но мы не даем ему имя файла? Например, что если мы введем:
>
> ```
> $ wc -l
>
> ```
>
> но не печатать `*.pdb` (или что\-нибудь еще) после команды? Поскольку у него нет имен файлов, `wc` предполагается , что он должен обрабатывать ввод, указанный в командной строке, поэтому он просто сидит и ждет, пока мы предоставим ему некоторые данные в интерактивном режиме. Однако снаружи мы видим только то, что он сидит: команда, похоже, ничего не делает.
>
> Если вы допустите такую ​​ошибку, вы можете выйти из этого состояния, удерживая нажатой клавишу управления ( Ctrl ), набрав букву C один раз и отпустив Ctrl клавишу. Ctrl + C

Какой из этих файлов содержит наименьшее количество строк? Это простой вопрос, когда есть только шесть файлов, но что, если их было 6000? Наш первый шаг к решению проблемы \- запустить команду:

```
$ wc -l *.pdb > lengths.txt

```

Символ больше, чем `>` , указывает оболочке **перенаправлять** вывод команды в файл, а не выводить его на экран. (Вот почему нет вывода на экран: вместо этого все, `wc` что печаталось, ушло в файл `lengths.txt` .) Оболочка создаст файл, если он не существует. Если файл существует, он будет автоматически перезаписан, что может привести к потере данных и, следовательно, требует некоторой осторожности. `ls lengths.txt` подтверждает, что файл существует:

```
$ ls lengths.txt

```

```
lengths.txt

```

Теперь мы можем отправить содержимое `lengths.txt` на экран с помощью `cat lengths.txt` . Команда `cat` получает свое имя от 'concatenate', то есть объединяет, и печатает содержимое файлов один за другим. В этом случае есть только один файл, так `cat` что просто покажите нам, что он содержит:

```
$ cat lengths.txt

```

```
  20  cubane.pdb
  12  ethane.pdb
   9  methane.pdb
  30  octane.pdb
  21  pentane.pdb
  15  propane.pdb
 107  total

```

> ## Выводить страницу за страницей
>
> Мы продолжим использовать `cat` этот урок для удобства и согласованности, но у него есть недостаток, заключающийся в том, что он всегда выгружает весь файл на ваш экран. Более полезной на практике является команда `less` , которую вы используете `less lengths.txt` . Это отображает экран файла, а затем останавливается. Вы можете перейти на один экран вперед, нажав пробел, или назад, нажав `b` . Нажмите, `q` чтобы выйти.

Теперь давайте использовать `sort` команду для сортировки ее содержимого.

> ## Что делает `sort -n` ?
>
> Если мы запустим `sort` файл, содержащий следующие строки:
>
> ```
> 10
> 2
> 19
> 22
> 6
>
> ```
>
> выход:
>
> ```
> 10
> 19
> 2
> 22
> 6
>
> ```
>
> Если мы запустим один и `sort -n` тот же вход, мы получим это:
>
> ```
> 2
> 6
> 10
> 19
> 22
>
> ```
>
> Объясните, почему `-n` имеет этот эффект.
>
> > ## Решение
> >
> > The `-n` option specifies a numerical rather than an alphanumerical sort.

Мы также будем использовать `-n` опцию, чтобы указать, что сортировка числовая, а не буквенно\-цифровая. Это *не* меняет файл; вместо этого он отправляет отсортированный результат на экран:

```
$ sort -n lengths.txt

```

```
  9  methane.pdb
 12  ethane.pdb
 15  propane.pdb
 20  cubane.pdb
 21  pentane.pdb
 30  octane.pdb
107  total

```

Мы можем поместить отсортированный список строк в другой временный файл, `sorted-lengths.txt` который вызывается `> sorted-lengths.txt` после команды, так же, как мы использовали `> lengths.txt` для вывода выходных данных `wc` в `lengths.txt` . Как только мы это сделаем, мы можем запустить другую команду, вызываемую, `head` чтобы получить первые несколько строк `sorted-lengths.txt` :

```
$ sort -n lengths.txt > sorted-lengths.txt
$ head -n 1 sorted-lengths.txt

```

```
  9  methane.pdb

```

Использование `-n 1` с `head` говорит о том, что нам нужна только первая строка файла; `-n 20` получит первые 20 и так далее. Поскольку `sorted-lengths.txt` содержит длины наших файлов, упорядоченные от наименьшего к наибольшему, вывод `head` должен быть файл с наименьшим количеством строк.

> ## Перенаправление в тот же файл
>
> Это очень плохая идея \- перенаправить вывод команды, которая работает с файлом, в тот же файл. Например:
>
> ```
> $ sort -n lengths.txt > lengths.txt
>
> ```
>
> Выполнение чего\-либо подобного может привести к неверным результатам и / или удалению содержимого `lengths.txt` .

> ## Что это `>>` значит?
>
> Мы видели использование `>` , но есть похожий оператор, `>>` который работает немного по\-другому. Мы узнаем о различиях между этими двумя операторами, напечатав несколько строк. Мы можем использовать `echo` команду для печати строк, например
>
> ```
> $ echo The echo command prints text
>
> ```
>
> ```
> The echo command prints text
>
> ```
>
> Теперь проверьте команды ниже, чтобы показать разницу между двумя операторами:
>
> ```
> $ echo hello > testfile01.txt
>
> ```
>
> а также:
>
> ```
> $ echo hello >> testfile02.txt
>
> ```
>
> Подсказка: попробуйте выполнить каждую команду дважды подряд, а затем проверить выходные файлы.
>
> > ## Решение
> >
> > In the first example with `>`, the string ‘hello’ is written to `testfile01.txt`, but the file gets overwritten each time we run the command.
> >
> > We see from the second example that the `>>` operator also writes ‘hello’ to a file (in this case`testfile02.txt`), but appends the string to the file if it already exists (i.e. when we run it for the second time).

> ## Добавление данных
>
> Мы уже встретили `head` команду, которая печатает строки с начала файла. `tail` аналогично, но печатает строки из конца файла.
>
> Рассмотрим файл `data-shell/data/animals.txt` . После этих команд выберите ответ, соответствующий файлу `animals-subset.txt` :
>
> ```
> $ head -n 3 animals.txt > animals-subset.txt
> $ tail -n 2 animals.txt >> animals-subset.txt
>
> ```
>
> 1.  Первые три строчки `animals.txt`
> 2.  Последние две строки `animals.txt`
> 3.  Первые три строки и последние две строки `animals.txt`
> 4.  Вторая и третья строчки `animals.txt`
>
> > ## Решение
> >
> > Option 3 is correct. For option 1 to be correct we would only run the `head` command. For option 2 to be correct we would only run the `tail` command. For option 4 to be correct we would have to pipe the output of `head` into `tail -n 2` by doing `head -n 3 animals.txt | tail -n 2 > animals-subset.txt`

Если вы думаете , что это заблуждение, вы в хорошей компании: даже когда вы понимаете , что `wc` , `sort` и `head` делать все эти промежуточные файлы сделать это трудно следовать тому , что происходит. Мы можем облегчить понимание, запустив `sort` и `head` вместе:

```
$ sort -n lengths.txt | head -n 1

```

```
  9  methane.pdb

```

Вертикальная черта `|` между двумя командами называется **конвейером** . Он сообщает оболочке, что мы хотим использовать вывод команды слева как ввод команды справа.

Ничто не мешает нам последовательно соединять трубы. То есть, например, мы можем отправить вывод `wc` непосредственно в `sort` , а затем результирующий вывод `head` . Таким образом , мы сначала использовать трубу , чтобы отправить вывод `wc` на `sort` :

```
$ wc -l *.pdb | sort -n

```

```
   9 methane.pdb
  12 ethane.pdb
  15 propane.pdb
  20 cubane.pdb
  21 pentane.pdb
  30 octane.pdb
 107 total

```

И теперь мы отправляем вывод этого канала через другой канал `head` , так что полный конвейер становится:

```
$ wc -l *.pdb | sort -n | head -n 1

```

```
   9  methane.pdb

```

Это точно так же, как математические функции вложенности, такие как *log (3x)* и говорят «log of the times *x* ». В нашем случае вычисление является «головкой сортировки строк `*.pdb` ».

Перенаправление и каналы, используемые в последних нескольких командах, показаны ниже:

![Перенаправления и Трубы](https://swcarpentry.github.io/shell-novice/fig/redirects-and-pipes.png)

> ## Трубопроводные команды вместе
>
> В нашем текущем каталоге мы хотим найти 3 файла с наименьшим количеством строк. Какая команда из перечисленных ниже будет работать?
>
> 1.  `wc -l * > sort -n > head -n 3`
> 2.  `wc -l * | sort -n | head -n 1-3`
> 3.  `wc -l * | head -n 3 | sort -n`
> 4.  `wc -l * | sort -n | head -n 3`
>
> > ## Решение
> >
> > Option 4 is the solution. The pipe character `|` is used to connect the output from one command to the input of another. `>` is used to redirect standard output to a file. Try it in the `data-shell/molecules` directory!

Именно из\-за этой идеи объединения программ Unix был настолько успешным. Вместо того, чтобы создавать огромные программы, которые пытаются делать много разных вещей, программисты Unix концентрируются на создании множества простых инструментов, каждый из которых хорошо выполняет свою работу и хорошо работает друг с другом. Эта модель программирования называется «трубы и фильтры». Мы уже видели трубы; **фильтр** представляет собой программу , как `wc` или , `sort` которая преобразует поток ввода в поток вывода. Почти все стандартные инструменты Unix могут работать таким образом: если не указано иное, они читают из стандартного ввода, что\-то делают с тем, что прочитали, и записывают в стандартный вывод.

Ключ в том, что любая программа, которая читает строки текста из стандартного ввода и записывает строки текста в стандартный вывод, может быть объединена с любой другой программой, которая ведет себя так же. Вы можете *и должны* писать свои программы таким образом, чтобы вы и другие люди могли помещать эти программы в каналы, чтобы увеличить их мощность.

> ## Понимание трубы
>
> Файл с именем `animals.txt` (в `data-shell/data` папке) содержит следующие данные:
>
> ```
> 2012-11-05,deer
> 2012-11-05,rabbit
> 2012-11-05,raccoon
> 2012-11-06,rabbit
> 2012-11-06,deer
> 2012-11-06,fox
> 2012-11-07,rabbit
> 2012-11-07,bear
>
> ```
>
> Какой текст проходит через каждый из каналов и окончательный редирект в конвейере ниже?
>
> ```
> $ cat animals.txt | head -n 5 | tail -n 3 | sort -r > final.txt
>
> ```
>
> Подсказка: создайте конвейер по одной команде за раз, чтобы проверить ваше понимание
>
> > ## Решение
> >
> > The `head` command extracts the first 5 lines from `animals.txt`. Then, the last 3 lines are extracted from the previous 5 by using the `tail` command. With the `sort -r` command those 3 lines are sorted in reverse order and finally, the output is redirected to a file `final.txt`. The content of this file can be checked by executing `cat final.txt`. The file should contain the following lines:
> >
> > ```
> > 2012-11-06,rabbit
> > 2012-11-06,deer
> > 2012-11-05,raccoon
> >
> > ```

> ## Строительство труб
>
> Для файла `animals.txt` из предыдущего упражнения рассмотрите следующую команду:
>
> ```
> $ cut -d , -f 2 animals.txt
>
> ```
>
> Команда `cut` используется для удаления или «вырезания» определенных разделов каждой строки в файле и `cut` предполагает, что строки будут разделены на столбцы Tab символом. Символ, используемый таким образом, называется **разделителем** . В приведенном выше примере мы используем `-d` опцию для указания запятой в качестве символа разделителя. Мы также использовали `-f` опцию, чтобы указать, что мы хотим извлечь второе поле (столбец). Это дает следующий вывод:
>
> ```
> deer
> rabbit
> raccoon
> rabbit
> deer
> fox
> rabbit
> bear
>
> ```
>
> Команда `uniq` отфильтровывает соседние совпадающие строки в файле. Как вы могли бы расширить этот конвейер (используя `uniq` и другую команду), чтобы узнать, каких животных содержит файл (без дубликатов в их именах)?
>
> > ## Решение
> >
> > ```
> > $ cut -d , -f 2 animals.txt | sort | uniq
> >
> > ```

> ## Какая труба?
>
> Файл `animals.txt` содержит 8 строк данных в следующем формате:
>
> ```
> 2012-11-05,deer
> 2012-11-05,rabbit
> 2012-11-05,raccoon
> 2012-11-06,rabbit
> ...
>
> ```
>
> У `uniq` команды есть `-c` опция, которая дает счетчик количества раз, когда строка встречается на входе. Предполагая, что ваш текущий каталог `data-shell/data/` , какую команду вы бы использовали для создания таблицы, которая показывает общее количество каждого типа животных в файле?
>
> 1.  `sort animals.txt | uniq -c`
> 2.  `sort -t, -k2,2 animals.txt | uniq -c`
> 3.  `cut -d, -f 2 animals.txt | uniq -c`
> 4.  `cut -d, -f 2 animals.txt | sort | uniq -c`
> 5.  `cut -d, -f 2 animals.txt | sort | uniq -c | wc -l`
>
> > ## Решение
> >
> > Option 4. is the correct answer. If you have difficulty understanding why, try running the commands, or sub\-sections of the pipelines (make sure you are in the `data-shell/data` directory).

## Трубопровод Нелле: проверка файлов

Нелле пробовала свои образцы через аналитические машины и создала 17 файлов в `north-pacific-gyre/2012-07-03` каталоге, описанном ранее. В качестве быстрой проверки работоспособности, начиная с ее домашнего каталога, Нелле набирает:

```
$ cd north-pacific-gyre/2012-07-03
$ wc -l *.txt

```

На выходе получается 18 строк, которые выглядят так:

```
300 NENE01729A.txt
300 NENE01729B.txt
300 NENE01736A.txt
300 NENE01751A.txt
300 NENE01751B.txt
300 NENE01812A.txt
... ...

```

Теперь она печатает это:

```
$ wc -l *.txt | sort -n | head -n 5

```

```
 240 NENE02018B.txt
 300 NENE01729A.txt
 300 NENE01729B.txt
 300 NENE01736A.txt
 300 NENE01751A.txt

```

Упс: один из файлов на 60 строк короче остальных. Когда она возвращается и проверяет ее, она видит, что она сделала этот анализ в 8:00 утра понедельника \- кто\-то, вероятно, использовал машину в выходные дни, и она забыла сбросить ее. Перед повторным запуском этого примера она проверяет, есть ли в файлах слишком много данных:

```
$ wc -l *.txt | sort -n | tail -n 5

```

```
 300 NENE02040B.txt
 300 NENE02040Z.txt
 300 NENE02043A.txt
 300 NENE02043B.txt
5040 total

```

Эти цифры выглядят хорошо \- но что там делает «Z» в третьей до последней строчке? Все ее образцы должны иметь маркировку «А» или «В»; условно, ее лаборатория использует 'Z', чтобы указать образцы с недостающей информацией. Чтобы найти других, как это, она делает это:

```
$ ls *Z.txt

```

```
NENE01971Z.txt    NENE02040Z.txt

```

Конечно же, когда она проверяет журнал на своем ноутбуке, ни для одной из этих выборок не записывается глубина. Поскольку уже слишком поздно получать информацию другим способом, она должна исключить эти два файла из своего анализа. Она могла бы удалить их, используя `rm` , но на самом деле есть некоторые анализы, которые она могла бы сделать позже, где глубина не имеет значения, поэтому вместо этого ей придется быть осторожным позже, чтобы выбрать файлы с использованием подстановочного выражения `*[AB].txt` . Как всегда, `*` соответствует любое количество символов; выражение `[AB]` соответствует либо «A», либо «B», так что это соответствует всем действительным файлам данных, которые она имеет.

> ## Подстановочные выражения
>
> Выражения с подстановочными знаками могут быть очень сложными, но иногда вы можете написать их способами, которые используют только простой синтаксис, за счет того, что они немного более многословны. Рассмотрим каталог `data-shell/north-pacific-gyre/2012-07-03` : подстановочное выражение `*[AB].txt` соответствует всем файлам, оканчивающимся на `A.txt` или `B.txt` . Представь, что ты забыл об этом.
>
> 1.  Можете ли вы сопоставить тот же набор файлов с основными подстановочными выражениями, которые не используют `[]` синтаксис? *Подсказка* : вам может понадобиться более одного выражения.
>
> 2.  Выражение, которое вы нашли, и выражение из урока соответствуют одному и тому же набору файлов в этом примере. Какая небольшая разница между выходами?
>
> 3.  При каких обстоятельствах ваше новое выражение выдаст сообщение об ошибке, а оригинальное \- нет?
>
>
> > ## Решение
> >
> > 1.  A solution using two wildcard expressions:
> >
> >     ```
> >      $ ls *A.txt
> >      $ ls *B.txt
> >
> >     ```
> >
> > 2.  The output from the new commands is separated because there are two commands.
> > 3.  When there are no files ending in `A.txt`, or there are no files ending in `B.txt`.

> ## Удаление ненужных файлов
>
> Предположим, вы хотите удалить обработанные файлы данных и оставить только необработанные файлы и сценарий обработки для сохранения хранилища. Необработанные файлы заканчиваются, `.dat` а обработанные файлы заканчиваются `.txt` . Что из следующего удалит все обработанные файлы данных и *только* обработанные файлы данных?
>
> 1.  `rm ?.txt`
> 2.  `rm *.txt`
> 3.  `rm * .txt`
> 4.  `rm *.*`
>
> > ## Решение
> >
> > 1.  This would remove `.txt` files with one\-character names
> > 2.  This is correct answer
> > 3.  The shell would expand `*` to match everything in the current directory, so the command would try to remove all matched files and an additional file called `.txt`
> > 4.  The shell would expand `*.*` to match all files with any extension, so this command would delete all files

> ## Ключевые моменты
>
> *   `cat` отображает содержимое своих входов.
>
> *   `head` отображает первые 10 строк своего ввода.
>
> *   `tail` отображает последние 10 строк своего ввода.
>
> *   `sort` сортирует свои входы.
>
> *   `wc` подсчитывает строки, слова и символы в своих входах.
>
> *   `command > file` перенаправляет вывод команды в файл (перезаписывая любой существующий контент).
>
> *   `command >> file` добавляет вывод команды в файл.
>
> *   `first | second` является конвейером: выходные данные первой команды используются в качестве входных данных для второй.
>
> *   Лучший способ использовать оболочку \- использовать каналы для объединения простых одноцелевых программ (фильтров).
>
