# Навигация по файлам и каталогам

> ## обзор
>
> **Обучение:** 30 мин.
> **Упражнения:** 10 мин.
>
> **Вопросов**
>
> *   Как я могу передвигаться на моем компьютере?
>
> *   Как я могу увидеть, какие файлы и каталоги у меня есть?
>
> *   Как я могу указать местоположение файла или каталога на моем компьютере?
>
>
> **Цели**
>
> *   Объясните сходства и различия между файлом и каталогом.
>
> *   Переведите абсолютный путь в относительный путь и наоборот.
>
> *   Создайте абсолютные и относительные пути, которые идентифицируют определенные файлы и каталоги.
>
> *   Продемонстрировать использование завершения вкладки и объяснить его преимущества.
>

Часть операционной системы, отвечающая за управление файлами и каталогами, называется **файловой системой** . Он организует наши данные в файлы, которые содержат информацию, и каталоги (также называемые «папками»), которые содержат файлы или другие каталоги.

Несколько команд часто используются для создания, проверки, переименования и удаления файлов и каталогов. Чтобы начать их изучать, перейдем к нашему открытому окну оболочки.

Сначала давайте выясним, где мы находимся, выполнив команду под названием `pwd` (которая означает «печать рабочего каталога»). Каталоги похожи на *места* \- в любое время, когда мы используем оболочку, мы находимся в одном месте, называемом нашим **текущим рабочим каталогом** . Команды в основном читают и пишут файлы в текущем рабочем каталоге, то есть «здесь», поэтому важно знать, где вы находитесь до запуска команды. `pwd` показывает, где вы находитесь:

```
$ pwd

```

```
/Users/nelle

```

Ответ компьютера `/Users/nelle` \- **домашний каталог** Nelle :

> ## Главная Каталог Вариация
>
> Путь к домашнему каталогу будет отличаться в разных операционных системах. В Linux это может выглядеть так `/home/nelle` , а в Windows \- `C:\Documents and Settings\nelle` или `C:\Users\nelle` . (Обратите внимание, что для разных версий Windows он может выглядеть немного по\-разному.) В будущих примерах мы использовали вывод Mac по умолчанию \- вывод Linux и Windows может немного отличаться, но в целом должен быть одинаковым.

Чтобы понять, что такое «домашний каталог», давайте посмотрим, как организована файловая система в целом. Ради этого примера мы проиллюстрируем файловую систему на компьютере нашего ученого Нелле. После этой иллюстрации вы будете изучать команды для изучения вашей собственной файловой системы, которая будет построена аналогичным образом, но не будет полностью идентичной.

На компьютере Нелле файловая система выглядит так:

![Файловая система состоит из корневого каталога, который содержит подкаталоги с именем bin, data, users и tmp.](https://swcarpentry.github.io/shell-novice/fig/filesystem.svg)

Вверху находится **корневой каталог, в** котором хранится все остальное. Мы ссылаемся на него, используя символ косой черты `/` , сам по себе; это ведущий слэш `/Users/nelle` .

Внутри этого каталога есть несколько других каталогов: `bin` (где хранятся некоторые встроенные программы), `data` (для разных файлов данных), `Users` (где находятся личные каталоги пользователей), `tmp` (для временных файлов, которые не нужно хранить долгосрочные) и тд.

Мы знаем, что наш текущий рабочий каталог `/Users/nelle` хранится внутри, `/Users` потому что `/Users` это первая часть его имени. Точно так же мы знаем, что `/Users` хранится в корневом каталоге, `/` потому что его имя начинается с `/` .

> ## Slashes
>
> Обратите внимание, что у `/` персонажа есть два значения . Когда он появляется в начале имени файла или каталога, он ссылается на корневой каталог. Когда он появляется *внутри* пути, это просто разделитель.

Ниже `/Users` мы находим один каталог для каждого пользователя с учетной записью на машине Нелле, ее коллегами *imhotep* и *larry* .

![Домашние каталоги](https://swcarpentry.github.io/shell-novice/fig/home-directories.svg)

Пользователя *Имхотеп* «файлы сек хранятся в `/Users/imhotep` , пользовательском *Larry* «с в `/Users/larry` и Нелле в `/Users/nelle` . Поскольку Nelle является пользователем в наших примерах здесь, именно поэтому мы получаем в `/Users/nelle` качестве нашего домашнего каталога. Как правило, когда вы открываете новую командную строку, вы находитесь в своем домашнем каталоге, чтобы начать.

Теперь давайте изучим команду, которая позволит нам увидеть содержимое нашей собственной файловой системы. Мы можем увидеть, что находится в нашем домашнем каталоге, запустив `ls` , что означает «перечисление»:

```
$ ls

```

```
Applications Documents    Library      Music        Public
Desktop      Downloads    Movies       Pictures

```

(Опять же, ваши результаты могут немного отличаться в зависимости от вашей операционной системы и от того, как вы настроили свою файловую систему.)

`ls` печатает имена файлов и каталогов в текущем каталоге. Мы можем сделать вывод более понятным, используя `-F` **опцию** (также известную как **переключатель** или **флаг** ), которая указывает `ls` классифицировать вывод, добавляя маркер к именам файлов и каталогов, чтобы указать, что это:

*   завершающий `/` указывает, что это каталог
*   `@` указывает на ссылку
*   `*` указывает на исполняемый файл

В зависимости от параметров по умолчанию оболочка может также использовать цвета, чтобы указать, является ли каждая запись файлом или каталогом.

```
$ ls -F

```

```
Applications/ Documents/    Library/      Music/        Public/
Desktop/      Downloads/    Movies/       Pictures/

```

Здесь мы видим, что наш домашний каталог содержит только **подкаталоги** . Любые имена в вашем выводе, которые не имеют классификационного символа, являются простыми старыми **файлами** .

## Общий синтаксис команды оболочки

Рассмотрим приведенную ниже команду как общий пример команды, которую мы разберем на составные части:

```
$ ls -F /

```

`ls` это **команда** , с **опцией** `-F` и **аргументом** `/` . Мы уже сталкивались с опциями (также называемыми **переключателями** или **флагами** ), которые начинаются либо с одной черты ( `-` ) или двух черт ( `--` ), и они изменяют поведение команды. Аргументы говорят команде, над чем работать (например, файлы и каталоги). Иногда параметры и аргументы называются **параметрами** . Команду можно вызвать с более чем одним параметром и несколькими аргументами, но команда не всегда требует аргумент или параметр.

Каждая часть разделена пробелами: если вы пропустите пробел между ними `ls` и `-F` оболочка будет искать вызываемую команду `ls-F` , которая не существует. Кроме того, капитализация может быть важной. Например, `ls -s` наряду с именами будет отображаться размер файлов и каталогов, а `ls -S` файлы и каталоги будут сортироваться по размеру, как показано ниже:

```
$ ls -s data-shell/data
total 116
 4 amino-acids.txt   4 animals.txt   4 morse.txt  12 planets.txt  76 sunspot.txt
 4 animal-counts     4 elements      4 pdb         4 salmon.txt
$ ls -S data-shell/data
sunspot.txt  animal-counts  pdb        amino-acids.txt  salmon.txt
planets.txt  elements       morse.txt  animals.txt

```

Собрав все это вместе, наша команда, приведенная выше, дает нам список файлов и каталогов в корневом каталоге `/` . Пример вывода, который вы можете получить из приведенной выше команды, приведен ниже:

```
$ ls -F /
Applications/         System/
Library/              Users/
Network/              Volumes/

```

### Получать помощь

`ls` имеет много других **вариантов** . Существует два распространенных способа узнать, как использовать команду и какие параметры она принимает:

1.  Мы можем передать `--help` параметр команде, такой как:

    ```
     $ ls --help

    ```

2.  Мы можем прочитать его руководство `man` , например:

    ```
     $ man ls

    ```

**В зависимости от вашей среды вы можете обнаружить, что только одна из этих работ (либо `man`или `--help`).** Мы опишем оба способа ниже.

#### `--help` вариант

Многие команды bash и написанные людьми программы, которые можно запускать изнутри bash, поддерживают `--help` возможность отображения дополнительной информации о том, как использовать команду или программу.

```
$ ls --help

```

```
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,
                               '--block-size=M' prints sizes in units of
                               1,048,576 bytes; see SIZE format below
  -B, --ignore-backups       do not list implied entries ending with ~
  -c                         with -lt: sort by, and show, ctime (time of last
                               modification of file status information);
                               with -l: show ctime and sort by name;
                               otherwise: sort by ctime, newest first
  -C                         list entries by columns
      --color[=WHEN]         colorize the output; WHEN can be 'always' (default
                               if omitted), 'auto', or 'never'; more info below
  -d, --directory            list directories themselves, not their contents
  -D, --dired                generate output designed for Emacs' dired mode
  -f                         do not sort, enable -aU, disable -ls --color
  -F, --classify             append indicator (one of */=>@|) to entries
      --file-type            likewise, except do not append '*'
      --format=WORD          across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            like -l --time-style=full-iso
  -g                         like -l, but do not list owner
      --group-directories-first
                             group directories before files;
                               can be augmented with a --sort option, but any
                               use of --sort=none (-U) disables grouping
  -G, --no-group             in a long listing, don't print group names
  -h, --human-readable       with -l and/or -s, print human readable sizes
                               (e.g., 1K 234M 2G)
      --si                   likewise, but use powers of 1000 not 1024
  -H, --dereference-command-line
                             follow symbolic links listed on the command line
      --dereference-command-line-symlink-to-dir
                             follow each command line symbolic link
                               that points to a directory
      --hide=PATTERN         do not list implied entries matching shell PATTERN
                               (overridden by -a or -A)
      --indicator-style=WORD  append indicator with style WORD to entry names:
                               none (default), slash (-p),
                               file-type (--file-type), classify (-F)
  -i, --inode                print the index number of each file
  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN
  -k, --kibibytes            default to 1024-byte blocks for disk usage
  -l                         use a long listing format
  -L, --dereference          when showing file information for a symbolic
                               link, show information for the file the link
                               references rather than for the link itself
  -m                         fill width with a comma separated list of entries
  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs
  -N, --literal              print raw entry names (don't treat e.g. control
                               characters specially)
  -o                         like -l, but do not list group information
  -p, --indicator-style=slash
                             append / indicator to directories
  -q, --hide-control-chars   print ? instead of nongraphic characters
      --show-control-chars   show nongraphic characters as-is (the default,
                               unless program is 'ls' and output is a terminal)
  -Q, --quote-name           enclose entry names in double quotes
      --quoting-style=WORD   use quoting style WORD for entry names:
                               literal, locale, shell, shell-always,
                               shell-escape, shell-escape-always, c, escape
  -r, --reverse              reverse order while sorting
  -R, --recursive            list subdirectories recursively
  -s, --size                 print the allocated size of each file, in blocks
  -S                         sort by file size, largest first
      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),
                               time (-t), version (-v), extension (-X)
      --time=WORD            with -l, show time as WORD instead of default
                               modification time: atime or access or use (-u);
                               ctime or status (-c); also use specified time
                               as sort key if --sort=time (newest first)
      --time-style=STYLE     with -l, show times using style STYLE:
                               full-iso, long-iso, iso, locale, or +FORMAT;
                               FORMAT is interpreted like in 'date'; if FORMAT
                               is FORMAT1<newline>FORMAT2, then FORMAT1 applies
                               to non-recent files and FORMAT2 to recent files;
                               if STYLE is prefixed with 'posix-', STYLE
                               takes effect only outside the POSIX locale
  -t                         sort by modification time, newest first
  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8
  -u                         with -lt: sort by, and show, access time;
                               with -l: show access time and sort by name;
                               otherwise: sort by access time, newest first
  -U                         do not sort; list entries in directory order
  -v                         natural sort of (version) numbers within text
  -w, --width=COLS           set output width to COLS.  0 means no limit
  -x                         list entries by lines instead of by columns
  -X                         sort alphabetically by entry extension
  -Z, --context              print any security context of each file
  -1                         list one file per line.  Avoid '\n' with -q or -b
      --help     display this help and exit
      --version  output version information and exit

The SIZE argument is an integer and optional unit (example: 10K is 10*1024).
Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).

Using color to distinguish file types is disabled both by default and
with --color=never.  With --color=auto, ls emits color codes only when
standard output is connected to a terminal.  The LS_COLORS environment
variable can change the settings.  Use the dircolors command to set it.

Exit status:
 0  if OK,
 1  if minor problems (e.g., cannot access subdirectory),
 2  if serious trouble (e.g., cannot access command-line argument).

GNU coreutils online help: <http://www.gnu.org/software/coreutils/>
Full documentation at: <http://www.gnu.org/software/coreutils/ls>
or available locally via: info '(coreutils) ls invocation'

```

> ## Неподдерживаемые параметры командной строки
>
> Если вы попытаетесь использовать опцию (флаг), которая не поддерживается, `ls` и другие команды обычно выводят сообщение об ошибке, похожее на:
>
> ```
> $ ls -j
>
> ```
>
> ```
> ls: invalid option -- 'j'
> Try 'ls --help' for more information.
>
> ```

#### `man` команда

Другой способ узнать `ls` это набрать

```
$ man ls

```

Это превратит ваш терминал в страницу с описанием `ls` команды и ее параметров и, если вам повезет, с некоторыми примерами ее использования.

Чтобы перемещаться по `man` страницам, вы можете использовать ↑ и ↓ для перемещения построчно, или попробовать B и Spacebar перейти вверх и вниз на полную страницу. Для поиска символа или слова на `man` страницах используйте / сопровождаемый символ или слово, которое вы ищете. Иногда поиск приводит к нескольким попаданиям. Если это так, вы можете перемещаться между ударами, используя N (для движения вперед) и Shift \+ N (для движения назад).

Чтобы **выйти** из `man` страниц, нажмите Q .

> ## Страницы руководства в Интернете
>
> Конечно, существует третий способ доступа к справке для команд: поиск в Интернете через веб\-браузер. При использовании интернет\-поиска включение фразы `unix man page` в ваш поисковый запрос поможет найти релевантные результаты.
>
> GNU предоставляет ссылки на свои [руководства,](http://www.gnu.org/manual/manual.html) включая [основные утилиты GNU](http://www.gnu.org/software/coreutils/manual/coreutils.html) , которые охватывают многие команды, представленные в этом уроке.

> ## Изучаем больше `ls` флагов
>
> Вы также можете использовать два варианта одновременно. Что делает команда `ls` при использовании с `-l` опцией? А что , если вы используете как `-l` и на `-h` вариант?
>
> Некоторые из его выводов касаются свойств, которые мы не рассматриваем в этом уроке (таких как права доступа к файлам и владение), но все же они должны быть полезны.
>
> > ## Решение
> >
> > The `-l` option makes `ls` use a **l**ong listing format, showing not only the file/directory names but also additional information such as the file size and the time of its last modification. If you use both the `-h` option and the `-l` option, this makes the file size ‘**h**uman readable’, i.e. displaying something like `5.3K` instead of `5369`.

> ## Листинг в обратном хронологическом порядке
>
> По умолчанию `ls` перечисляет содержимое каталога в алфавитном порядке по имени. Команда `ls -t` перечисляет элементы по времени последнего изменения, а не по алфавиту. Команда `ls -r` выводит содержимое каталога в обратном порядке. Какой файл отображается последняя , когда вы объединяете `-t` и `-r` флаги? Подсказка: вам может понадобиться использовать `-l` флаг, чтобы увидеть даты последнего изменения.
>
> > ## Решение
> >
> > The most recently changed file is listed last when using `-rt`. This can be very useful for finding your most recent edits or checking to see if a new output file was written.

Мы также можем использовать, `ls` чтобы увидеть содержимое другого каталога. Давайте посмотрим на наш `Desktop` каталог, выполнив `ls -F Desktop` команду `ls` с `-F` **параметром** и **аргументом** `Desktop` . Аргумент `Desktop` говорит, `ls` что мы хотим получить список чего\-то другого, кроме нашего текущего рабочего каталога:

```
$ ls -F Desktop

```

```
data-shell/

```

Ваш вывод должен быть списком всех файлов и подкаталогов на вашем рабочем столе, включая `data-shell` каталог, который вы скачали при [настройке этого урока](https://swcarpentry.github.io/shell-novice/setup.html) . Посмотрите на свой рабочий стол, чтобы убедиться, что ваш вывод точен.

Как вы можете теперь видеть, использование оболочки bash сильно зависит от идеи, что ваши файлы организованы в иерархическую файловую систему. Таким образом, иерархическая организация вещей помогает нам отслеживать нашу работу: можно поместить сотни файлов в наш домашний каталог, точно так же, как можно складывать сотни печатных документов на нашем столе, но это стратегия, которая наносит ущерб самому себе.

Теперь, когда мы знаем, что `data-shell` каталог находится на нашем рабочем столе, мы можем сделать две вещи.

Во\-первых, мы можем посмотреть на его содержимое, используя ту же стратегию, что и раньше, передав имя каталога `ls` :

```
$ ls -F Desktop/data-shell

```

```
creatures/          molecules/          notes.txt           solar.pdf
data/               north-pacific-gyre/ pizza.cfg           writing/

```

Во\-вторых, мы можем изменить наше местоположение на другой каталог, поэтому мы больше не находимся в нашем домашнем каталоге.

За командой для изменения местоположения `cd` следует имя каталога, чтобы изменить наш рабочий каталог. `cd` означает «изменить каталог», что немного вводит в заблуждение: команда не меняет каталог, она меняет представление оболочки о том, в каком каталоге мы находимся.

Допустим, мы хотим перейти в `data` каталог, который мы видели выше. Мы можем использовать следующую серию команд, чтобы добраться туда:

```
$ cd Desktop
$ cd data-shell
$ cd data

```

Эти команды переместят нас из нашего домашнего каталога на рабочий стол, затем в `data-shell` каталог, затем в `data` каталог. Вы заметите, что `cd` ничего не печатает. Это нормально. Многие команды оболочки ничего не выводят на экран при успешном выполнении. Но если мы бежим `pwd` за ним, мы можем видеть, что мы сейчас в `/Users/nelle/Desktop/data-shell/data` . Если мы сейчас запускаем `ls` без аргументов, он перечисляет содержимое `/Users/nelle/Desktop/data-shell/data` , потому что это то, где мы сейчас находимся:

```
$ pwd

```

```
/Users/nelle/Desktop/data-shell/data

```

```
$ ls -F

```

```
amino-acids.txt   elements/     pdb/	        salmon.txt
animals.txt       morse.txt     planets.txt     sunspot.txt

```

Теперь мы знаем, как пройти по дереву каталогов, но как мы пойдем вверх? Мы можем попробовать следующее:

```
$ cd data-shell

```

```
-bash: cd: data-shell: No such file or directory

```

Но мы получаем ошибку! Почему это?

Пока с нашими методами `cd` можно видеть только подкаталоги внутри вашего текущего каталога. Есть разные способы просмотра каталогов над вашим текущим местоположением; Начнем с самого простого.

В оболочке есть ярлык для перехода на один уровень каталога, который выглядит следующим образом:

```
$ cd ..

```

`..` является специальным именем каталога, означающим «каталог, содержащий этот каталог», или, более кратко, **родителем** текущего каталога. Конечно же, если мы бежим `pwd` после бега `cd ..` , мы снова в `/Users/nelle/Desktop/data-shell` :

```
$ pwd

```

```
/Users/nelle/Desktop/data-shell

```

Специальный каталог `..` обычно не появляется при запуске `ls` . Если мы хотим , чтобы отобразить его, мы можем дать `ls` в `-a` опции:

```
$ ls -F -a

```

```
./   .bash_profile  data/       north-pacific-gyre/  pizza.cfg  thesis/
../  creatures/     molecules/  notes.txt            solar.pdf  writing/

```

`-a` обозначает «показать все»; он заставляет `ls` нас показывать имена файлов и каталогов, которые начинаются с `.` , например, `..` (который, если мы находимся `/Users/nelle` , относится к `/Users` каталогу). Как вы можете видеть, он также отображает другой специальный каталог, который только что вызван `.` , что означает «текущая рабочая». каталог». Название может показаться излишним, но мы скоро увидим его использование.

Обратите внимание, что в большинстве инструментов командной строки несколько параметров могут быть объединены с одним `-` и без пробелов между параметрами: `ls -F -a` эквивалентно `ls -Fa` .

> ## Другие скрытые файлы
>
> Помимо скрытых каталогов `..` и `.` , вы также можете увидеть файл с именем `.bash_profile` . Этот файл обычно содержит параметры конфигурации оболочки. Вы также можете увидеть другие файлы и каталоги, начинающиеся с `.` . Обычно это файлы и каталоги, которые используются для настройки различных программ на вашем компьютере. Префикс `.` используется для того, чтобы эти файлы конфигурации не загромождали терминал при использовании стандартной `ls` команды.

> ## Ортогональность
>
> Особые имена `.` и `..` не принадлежат `cd` ; они интерпретируются одинаково каждой программой. Например, если мы находимся `/Users/nelle/data` , команда `ls ..` выдаст нам список `/Users/nelle` . Когда значения частей одинаковы, независимо от того, как они объединены, программисты говорят, что они **ортогональны** : ортогональные системы, как правило, легче усваиваются людьми, потому что существует меньше особых случаев и исключений, которые нужно отслеживать.

Затем они являются основными командами для навигации по файловой системе на вашем компьютере: `pwd` , `ls` и `cd` . Давайте рассмотрим некоторые варианты этих команд. Что произойдет, если вы печатаете `cd` самостоятельно, без указания каталога?

```
$ cd

```

Как вы можете проверить, что случилось? `pwd` дает нам ответ!

```
$ pwd

```

```
/Users/nelle

```

Оказывается, что `cd` без аргументов вы вернетесь в свой домашний каталог, и это здорово, если вы потерялись в своей файловой системе.

Давайте попробуем вернуться в `data` каталог с ранее. В прошлый раз мы использовали три команды, но на самом деле мы можем связать вместе список каталогов за `data` один шаг:

```
$ cd Desktop/data-shell/data

```

Убедитесь, что мы переехали в нужное место, запустив `pwd` и `ls -F`

Если мы хотим подняться на один уровень вверх от каталога данных, мы могли бы использовать `cd ..` . Но есть и другой способ перехода в любой каталог, независимо от вашего текущего местоположения.

До сих пор при указании имен каталогов или даже пути к каталогу (как указано выше) мы использовали **относительные пути** . Когда вы используете относительный путь с такой командой, как `ls` или `cd` , он пытается найти это местоположение там, где мы находимся, а не в корне файловой системы.

Тем не менее, можно указать **абсолютный путь** к каталогу, включив весь его путь из корневого каталога, который обозначен косой чертой. Ведущий `/` указывает компьютеру следовать по пути из корня файловой системы, поэтому он всегда ссылается на ровно один каталог, где бы мы ни находились, когда запускаем команду.

Это позволяет нам перемещаться в наш `data-shell` каталог из любой точки файловой системы (в том числе изнутри `data` ). Чтобы найти абсолютный путь, который мы ищем, мы можем использовать `pwd` и затем извлечь фрагмент, к которому нам нужно перейти `data-shell` .

```
$ pwd

```

```
/Users/nelle/Desktop/data-shell/data

```

```
$ cd /Users/nelle/Desktop/data-shell

```

Запустите `pwd` и `ls -F` убедитесь, что мы в каталоге, который мы ожидаем.

> ## Еще два ярлыка
>
> Оболочка интерпретирует символ `~` (тильда) в начале пути для обозначения «домашнего каталога текущего пользователя». Например, если домашний каталог Нелла есть `/Users/nelle` , то `~/data` это эквивалентно `/Users/nelle/data` . Это работает только если это первый символ в пути: `here/there/~/elsewhere` это *не* `here/there/Users/nelle/elsewhere` .
>
> Другим ярлыком является `-` (тире) символ. `cd` переведет `-` в *предыдущий каталог, в* котором *я находился* , что быстрее, чем запоминание, а затем *ввод* полного пути. Это *очень* эффективный способ перемещения между каталогами. Разница между `cd ..` и `cd -` в том , что бывший приносит вам *до* , в то время как последний приносит вам *обратно* . Вы можете думать об этом как о кнопке « *Последний канал»* на пульте телевизора.

> ## Абсолют против относительных путей
>
> Начиная с того `/Users/amanda/data` , какую из следующих команд Аманда могла бы использовать для перехода к своему домашнему каталогу, а какая `/Users/amanda` ?
>
> 1.  `cd .`
> 2.  `cd /`
> 3.  `cd /home/amanda`
> 4.  `cd ../..`
> 5.  `cd ~`
> 6.  `cd home`
> 7.  `cd ~/data/..`
> 8.  `cd`
> 9.  `cd ..`
>
> > ## Решение
> >
> > 1.  No: `.` stands for the current directory.
> > 2.  No: `/` stands for the root directory.
> > 3.  No: Amanda’s home directory is `/Users/amanda`.
> > 4.  No: this goes up two levels, i.e. ends in `/Users`.
> > 5.  Yes: `~` stands for the user’s home directory, in this case `/Users/amanda`.
> > 6.  No: this would navigate into a directory `home` in the current directory if it exists.
> > 7.  Yes: unnecessarily complicated, but correct.
> > 8.  Yes: shortcut to go back to the user’s home directory.
> > 9.  Yes: goes up one level.

> ## Относительное разрешение пути
>
> Используя диаграмму файловой системы ниже, если `pwd` отображается `/Users/thing` , что будет `ls -F ../backup` отображаться?
>
> 1.  `../backup: No such file or directory`
> 2.  `2012-12-01 2013-01-08 2013-01-27`
> 3.  `2012-12-01/ 2013-01-08/ 2013-01-27/`
> 4.  `original/ pnas_final/ pnas_sub/`
>
> ![Файловая система для вопросов о вызовах](https://swcarpentry.github.io/shell-novice/fig/filesystem-challenge.svg)
>
> > ## Решение
> >
> > 1.  No: there *is* a directory `backup` in `/Users`.
> > 2.  No: this is the content of `Users/thing/backup`, but with `..` we asked for one level further up.
> > 3.  No: see previous explanation.
> > 4.  Yes: `../backup/` refers to `/Users/backup/`.

> ## `ls` Понимание прочитанного
>
> Используя диаграмму файловой системы, приведенную ниже, если она `pwd` отображается `/Users/backup` и `-r` указывает `ls` на отображение вещей в обратном порядке, какие команды приведут к следующему выводу:
>
> ```
> pnas_sub/ pnas_final/ original/
>
> ```
>
> ![Файловая система для вопросов о вызовах](https://swcarpentry.github.io/shell-novice/fig/filesystem-challenge.svg)
>
> 1.  `ls pwd`
> 2.  `ls -r -F`
> 3.  `ls -r -F /Users/backup`
>
> > ## Решение
> >
> > 1.  No: `pwd` is not the name of a directory.
> > 2.  Yes: `ls` without directory argument lists files and directories in the current directory.
> > 3.  Yes: uses the absolute path explicitly.

### Трубопровод Нелле: Организация файлов

Зная это много о файлах и каталогах, Nelle готова организовать файлы, которые создаст машина для анализа белка. Сначала она создает каталог с именем `north-pacific-gyre` (чтобы напомнить себе, откуда поступили данные). Внутри этого она создает каталог с именем `2012-07-03` , с которого она начала обрабатывать образцы. Раньше она использовала такие имена, как `conference-paper` и `revised-results` , но ей было трудно понять их через пару лет. (Последняя капля была, когда она создала каталог под названием `revised-revised-results-3` .)

> ## Сортировка вывода
>
> Nelle называет свои каталоги «год\-месяц\-день» с ведущими нулями для месяцев и дней, потому что оболочка отображает имена файлов и каталогов в алфавитном порядке. Если бы она использовала названия месяцев, декабрь наступил бы до июля; если бы она не использовала начальные нули, ноябрь («11») наступил бы до июля («7»). Аналогичным образом, указание года означает, что июнь 2012 года наступит раньше июня 2013 года.

Каждый из ее физических образцов помечен в соответствии с соглашением ее лаборатории с уникальным идентификатором из десяти символов, например, «NENE01729A». Это то, что она использовала в своем журнале сбора для записи местоположения, времени, глубины и других характеристик образца, поэтому она решает использовать его как часть имени каждого файла данных. Поскольку выход Пробирной машины обычный текст, она будет вызывать ее файлы `NENE01729A.txt` , `NENE01812A.txt` и так далее. Все файлы 1520 будут помещены в один каталог.

Теперь в своей текущей директории `data-shell` Nelle может видеть, какие файлы она имеет, используя команду:

```
$ ls north-pacific-gyre/2012-07-03/

```

Это много, чтобы напечатать, но она может позволить оболочке выполнять большую часть работы через то, что называется **завершением табуляции** . Если она печатает:

```
$ ls nor

```

и затем нажимает Tab (клавиша табуляции на ее клавиатуре), оболочка автоматически завершает имя каталога для нее:

```
$ ls north-pacific-gyre/

```

Если она нажмет Tab снова, Bash добавит `2012-07-03/` команду, так как это единственное возможное завершение. Повторное нажатие Tab ничего не делает, так как есть 19 возможностей; Tab двойное нажатие вызывает список всех файлов и так далее. Это называется **завершением табуляции** , и мы увидим это во многих других инструментах по мере продвижения.

> ## Ключевые моменты
>
> *   Файловая система отвечает за управление информацией на диске.
>
> *   Информация хранится в файлах, которые хранятся в каталогах (папках).
>
> *   В каталогах также могут храниться другие каталоги, которые образуют дерево каталогов.
>
> *   `cd path` изменяет текущий рабочий каталог.
>
> *   `ls path` печатает список определенного файла или каталога; `ls` в своих списках текущий рабочий каталог.
>
> *   `pwd` печатает текущий рабочий каталог пользователя.
>
> *   `/` сам по себе является корневым каталогом всей файловой системы.
>
> *   Относительный путь указывает местоположение, начиная с текущего местоположения.
>
> *   Абсолютный путь указывает местоположение из корня файловой системы.
>
> *   Имена каталогов в пути разделяются `/` в Unix, но `\` в Windows.
>
> *   `..` означает «каталог выше текущего»; `.` сам по себе означает «текущий каталог».
>
