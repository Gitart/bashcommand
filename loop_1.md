# Loops

> ## обзор
>
> **Обучение:** 40 мин.
> **Упражнения:** 10 мин.
>
> **Вопросов**
>
> *   Как я могу выполнить одни и те же действия для разных файлов?
>
>
> **Цели**
>
> *   Напишите цикл, который применяет одну или несколько команд отдельно к каждому файлу в наборе файлов.
>
> *   Проследите значения, принятые переменной цикла во время выполнения цикла.
>
> *   Объясните разницу между именем переменной и ее значением.
>
> *   Объясните, почему пробелы и некоторые знаки препинания не должны использоваться в именах файлов.
>
> *   Продемонстрируйте, как увидеть, какие команды были недавно выполнены.
>
> *   Повторно запустите недавно выполненные команды без их повторного ввода.
>

**Циклы** \- это программная конструкция, которая позволяет нам повторять команду или набор команд для каждого элемента в списке. Как таковые, они являются ключом к повышению производительности за счет автоматизации. Как и в случае с подстановочными знаками и завершением табуляции, использование циклов также уменьшает количество требуемой печати (и, следовательно, уменьшает количество ошибок при печати).

Предположим , у нас есть несколько сотен файлов данных генома с именами `basilisk.dat` , `minotaur.dat` и `unicorn.dat` . В этом примере мы будем использовать `creatures` каталог, в котором есть только три файла примеров, но принципы могут быть применены ко многим другим файлам одновременно.

Структура этих файлов одинакова: общее имя, классификация и дата обновления представлены в первых трех строках, а последовательности ДНК \- в следующих строках. Давайте посмотрим на файлы:

```
head -n 5 basilisk.dat minotaur.dat unicorn.dat

```

Мы хотели бы распечатать классификацию для каждого вида, которая приводится во второй строке каждого файла. Для каждого файла нам нужно выполнить команду `head -n 2` и передать ее в `tail -n 1` . Мы будем использовать цикл для решения этой проблемы, но сначала давайте рассмотрим общую форму цикла:

```
for thing in list_of_things
do
    operation_using $thing    # Indentation within the loop is not required, but aids legibility
done

```

и мы можем применить это к нашему примеру следующим образом:

```
$ for filename in basilisk.dat minotaur.dat unicorn.dat
> do
>    head -n 2 $filename | tail -n 1
> done

```

```
CLASSIFICATION: basiliscus vulgaris
CLASSIFICATION: bos hominus
CLASSIFICATION: equus monoceros

```

> ## Следуйте подсказке
>
> Подсказка оболочки меняется с `$` на `>` и обратно, когда мы печатали в нашем цикле. Второе приглашение `>` отличается от напоминания о том, что мы еще не завершили ввод полной команды. Точка с запятой, `;` может использоваться для разделения двух команд, записанных в одной строке.

Когда оболочка видит ключевое слово `for` , она знает, что нужно повторить команду (или группу команд) один раз для каждого элемента в списке. Каждый раз, когда выполняется цикл (называемый итерацией), элемент в списке последовательно присваивается **переменной** , и команды внутри цикла выполняются, прежде чем перейти к следующему элементу в списке. Внутри цикла мы вызываем значение переменной, помещая `$` перед ней. `$` Говорит интерпретатор оболочки , чтобы рассматривать переменную как имя переменной и заменить его значение на своем месте, а не рассматривать его как текст или внешней командой.

В этом примере, список трех имен файлов: `basilisk.dat` , `minotaur.dat` , и `unicorn.dat` . Каждый раз, когда цикл повторяется, он назначает имя файла переменной `filename` и запускает `head` команду. Первый раз через цикл, `$filename` это `basilisk.dat` . Интерпретатор запускает команду `head` на `basilisk.dat` и труб первых двух линий к `tail` команде, которая затем печатает вторую строку `basilisk.dat` . Для второй итерации `$filename` становится `minotaur.dat` . На этот раз, оболочка работает `head` на `monotaur.dat` и труб первых двух линий к `tail` команде, которая затем печатает вторую строку `monotaur.dat` . Для третьей итерации `$filename` становится `unicorn.dat` , поэтому оболочка запускает `head` команду для этого файла, и `tail` на выходе этого. Поскольку в списке было всего три элемента, оболочка выходит из `for` цикла.

> ## Одинаковые символы, разные значения
>
> Здесь мы видим, `>` что используется приглашение оболочки, тогда `>` как также используется для перенаправления вывода. Точно так же `$` используется как приглашение оболочки, но, как мы видели ранее, оно также используется для запроса оболочки, чтобы получить значение переменной.
>
> Если *оболочка* печатает `>` или `$` затем ожидает, что вы что\-то напечатаете, а символ является подсказкой.
>
> Если *вы* печатаете `>` или `$` вы сами, это указание от вас, что оболочка должна перенаправить вывод или получить значение переменной.

При использовании переменных также возможно поместить имена в фигурные скобки, чтобы четко разграничить имя переменной: `$filename` эквивалентно `${filename}` , но отличается от `${file}name` . Вы можете найти эту запись в программах других людей.

Мы назвали переменную в этом цикле `filename` , чтобы сделать ее цель более понятной для читателей. Сама оболочка не заботится о том, как называется переменная; если бы мы написали этот цикл как:

```
$ for x in basilisk.dat minotaur.dat unicorn.dat
> do
>    head -n 2 $x | tail -n 1
> done

```

или:

```
$ for temperature in basilisk.dat minotaur.dat unicorn.dat
> do
>    head -n 2 $temperature | tail -n 1
> done

```

это будет работать точно так же. *Не делай этого.* Программы полезны только в том случае, если люди могут их понять, поэтому бессмысленные имена (например `x` ) или вводящие в заблуждение имена (например `temperature` ) увеличивают вероятность того, что программа не будет делать то, что думают ее читатели.

> ## Переменные в циклах
>
> Это упражнение относится к `data-shell/molecules` каталогу. `ls` дает следующий вывод:
>
> ```
> cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
>
> ```
>
> Каков вывод следующего кода?
>
> ```
> $ for datafile in *.pdb
> > do
> >    ls *.pdb
> > done
>
> ```
>
> Теперь, каков вывод следующего кода?
>
> ```
> $ for datafile in *.pdb
> > do
> >	ls $datafile
> > done
>
> ```
>
> Почему эти два цикла дают разные результаты?
>
> > ## Решение
> >
> > The first code block gives the same output on each iteration through the loop. Bash expands the wildcard `*.pdb` within the loop body (as well as before the loop starts) to match all files ending in `.pdb` and then lists them using `ls`. The expanded loop would look like this:
> >
> > ```
> > $ for datafile in cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
> > > do
> > >	ls cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
> > > done
> >
> > ```
> >
> > ```
> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
> > cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
> >
> > ```
> >
> > The second code block lists a different file on each loop iteration. The value of the `datafile` variable is evaluated using `$datafile`, and then listed using `ls`.
> >
> > ```
> > cubane.pdb
> > ethane.pdb
> > methane.pdb
> > octane.pdb
> > pentane.pdb
> > propane.pdb
> >
> > ```

> ## Ограничение наборов файлов
>
> Каков будет результат запуска следующего цикла в `data-shell/molecules` каталоге?
>
> ```
> $ for filename in c*
> > do
> >    ls $filename
> > done
>
> ```
>
> 1.  Нет файлов в списке.
> 2.  Все файлы перечислены.
> 3.  Только `cubane.pdb` , `octane.pdb` и `pentane.pdb` перечислены.
> 4.  Только `cubane.pdb` в списке.
>
> > ## Решение
> >
> > 4 is the correct answer. `*` matches zero or more characters, so any file name starting with the letter c, followed by zero or more other characters will be matched.
>
> Чем будет отличаться вывод от использования этой команды?
>
> ```
> $ for filename in *c*
> > do
> >    ls $filename
> > done
>
> ```
>
> 1.  Те же файлы будут перечислены.
> 2.  Все файлы перечислены в этот раз.
> 3.  На этот раз нет файлов.
> 4.  Файлы `cubane.pdb` и `octane.pdb` будут перечислены.
> 5.  Только файл `octane.pdb` будет в списке.
>
> > ## Решение
> >
> > 4 is the correct answer. `*` matches zero or more characters, so a file name with zero or more characters before a letter c and zero or more characters after the letter c will be matched.

> ## Сохранение в файл в цикле \- часть первая
>
> В `data-shell/molecules` каталоге, каков эффект этого цикла?
>
> ```
> for alkanes in *.pdb
> do
>     echo $alkanes
>     cat $alkanes > alkanes.pdb
> done
>
> ```
>
> 1.  Отпечатки `cubane.pdb` , `ethane.pdb` , `methane.pdb` , `octane.pdb` , `pentane.pdb` и `propane.pdb` , а текст из `propane.pdb` будет сохранен в файле с именем `alkanes.pdb` .
> 2.  Отпечатки `cubane.pdb` , `ethane.pdb` и `methane.pdb` , и текст из всех трех файлов будут объединены и сохранены в файле с именем `alkanes.pdb` .
> 3.  Отпечатки `cubane.pdb` , `ethane.pdb` , `methane.pdb` , `octane.pdb` , и `pentane.pdb` , а текст из `propane.pdb` будет сохранен в файле с именем `alkanes.pdb` .
> 4.  Ни один из вышеперечисленных.
>
> > ## Решение
> >
> > 1.  The text from each file in turn gets written to the `alkanes.pdb` file. However, the file gets overwritten on each loop interation, so the final content of `alkanes.pdb` is the text from the `propane.pdb` file.

> ## Сохранение в файл в цикле \- часть вторая
>
> Также в `data-shell/molecules` каталоге, что будет вывод следующего цикла?
>
> ```
> for datafile in *.pdb
> do
>     cat $datafile >> all.pdb
> done
>
> ```
>
> 1.  Весь текст из `cubane.pdb` , `ethane.pdb` , `methane.pdb` , `octane.pdb` и `pentane.pdb` будут сцеплены и сохранены в файл с именем `all.pdb` .
> 2.  Текст из `ethane.pdb` будет сохранен в файл с именем `all.pdb` .
> 3.  Весь текст из `cubane.pdb` , `ethane.pdb` , `methane.pdb` , `octane.pdb` , `pentane.pdb` и `propane.pdb` будут сцеплены и сохранены в файл с именем `all.pdb` .
> 4.  Весь текст из `cubane.pdb` , `ethane.pdb` , `methane.pdb` , `octane.pdb` , `pentane.pdb` и `propane.pdb` будет выведен на экран и сохраняются в файле с именем `all.pdb` .
>
> > ## Решение
> >
> > 3 is the correct answer. `>>` appends to a file, rather than overwriting it with the redirected output from a command. Given the output from the `cat` command has been redirected, nothing is printed to the screen.

Давайте продолжим с нашим примером в `data-shell/creatures` каталоге. Вот немного более сложный цикл:

```
$ for filename in *.dat
> do
>     echo $filename
>     head -n 100 $filename | tail -n 20
> done

```

Оболочка начинается с расширения, `*.dat` чтобы создать список файлов, которые она будет обрабатывать. Затем **тело цикла** выполняет две команды для каждого из этих файлов. Первая команда, `echo` выводит свои аргументы командной строки в стандартный вывод. Например:

```
$ echo hello there

```

печатает:

```
hello there

```

В этом случае, поскольку оболочка расширяется `$filename` до имени файла, `echo $filename` печатается имя файла. Обратите внимание, что мы не можем написать это как:

```
$ for filename in *.dat
> do
>     $filename
>     head -n 100 $filename | tail -n 20
> done

```

потому что тогда при первом `$filename` расширении `basilisk.dat` цикла оболочка будет пытаться запускаться `basilisk.dat` как программа. Наконец, `head` и `tail` комбинация выбирает строки 81\-100 из любого файла обрабатывается (предполагается , что файл имеет по крайней мере 100 строк).

> ## Пробелы в именах
>
> Пробелы используются для разделения элементов списка, которые мы собираемся зациклить. Если один из этих элементов содержит символ пробела, нам нужно заключить его в кавычки и сделать то же самое с нашей переменной цикла. Предположим, что наши файлы данных названы:
>
> ```
> red dragon.dat
> purple unicorn.dat
>
> ```
>
> Чтобы зациклить эти файлы, нам нужно добавить двойные кавычки, например, так:
>
> ```
> $ for filename in "red dragon.dat" "purple unicorn.dat"
> > do
> >     head -n 100 "$filename" | tail -n 20
> > done
>
> ```
>
> Проще избежать использования пробелов (или других специальных символов) в именах файлов.
>
> Указанные выше файлы не существуют, поэтому, если мы запустим приведенный выше код, `head` команда не сможет их найти, однако в возвращенном сообщении об ошибке будет указано имя ожидаемых файлов:
>
> ```
> head: cannot open ‘red dragon.dat’ for reading: No such file or directory
> head: cannot open ‘purple unicorn.dat’ for reading: No such file or directory
>
> ```
>
> Попробуйте удалить кавычки `$filename` в цикле выше, чтобы увидеть влияние кавычек на пробелы. Обратите внимание, что мы получаем результат из команды цикла для unicorn.dat, когда запускаем этот код в `creatures` каталоге:
>
> ```
> head: cannot open ‘red’ for reading: No such file or directory
> head: cannot open ‘dragon.dat’ for reading: No such file or directory
> head: cannot open ‘purple’ for reading: No such file or directory
> CGGTACCGAA
> AAGGGTCGCG
> CAAGTGTTCC
>
> ```

Мы хотели бы изменить каждый из файлов `data-shell/creatures` , но также сохранить версию исходных файлов, назвав копии `original-basilisk.dat` и `original-unicorn.dat` . Мы не можем использовать:

```
$ cp *.dat original-*.dat

```

потому что это расширилось бы до:

```
$ cp basilisk.dat minotaur.dat unicorn.dat original-*.dat

```

Это не создаст резервную копию наших файлов, вместо этого мы получим ошибку:

```
cp: target `original-*.dat' is not a directory

```

Эта проблема возникает, когда `cp` получает более двух входов. Когда это происходит, он ожидает, что последний вход будет каталогом, куда он может скопировать все файлы, которые он передал. Поскольку не существует каталог с именем `original-*.dat` в `creatures` каталоге мы получаем ошибку.

Вместо этого мы можем использовать цикл:

```
$ for filename in *.dat
> do
>     cp $filename original-$filename
> done

```

Этот цикл запускает `cp` команду один раз для каждого имени файла. При первом `$filename` расширении `basilisk.dat` оболочка выполняет:

```
cp basilisk.dat original-basilisk.dat

```

Во второй раз команда выглядит так:

```
cp minotaur.dat original-minotaur.dat

```

В третий и последний раз команда выглядит так:

```
cp unicorn.dat original-unicorn.dat

```

Поскольку `cp` команда обычно не выдает никаких результатов, трудно проверить, что цикл делает правильные вещи. Однако ранее мы узнали, как печатать строки с помощью `echo` , и мы можем изменить цикл, который будет использоваться `echo` для печати наших команд без их фактического выполнения. Таким образом, мы можем проверить, какие команды *будут* выполняться в неизмененном цикле.

Следующая диаграмма показывает, что происходит, когда выполняется модифицированный цикл, и демонстрирует, как разумное использование `echo` является хорошим методом отладки.

![Для цикла в действии](https://swcarpentry.github.io/shell-novice/fig/shell_script_for_loop_flow_chart.svg)

## Трубопровод Нелле: Обработка файлов

Теперь Нелле готова обработать свои файлы данных, используя `goostats` сценарий оболочки, написанный ее руководителем. Это вычисляет некоторую статистику из файла образца белка и принимает два аргумента:

1.  входной файл (содержащий необработанные данные)
2.  выходной файл (для хранения рассчитанной статистики)

Поскольку она все еще учится использовать оболочку, она решает создавать необходимые команды поэтапно. Ее первый шаг \- убедиться, что она может выбрать правильные входные файлы \- помните, это те, чьи имена заканчиваются на «A» или «B», а не «Z». Начиная со своего домашнего каталога, Нелле набирает:

```
$ cd north-pacific-gyre/2012-07-03
$ for datafile in NENE*[AB].txt
> do
>     echo $datafile
> done

```

```
NENE01729A.txt
NENE01729B.txt
NENE01736A.txt
...
NENE02043A.txt
NENE02043B.txt

```

Ее следующий шаг \- решить, как назвать файлы, `goostats` которые создаст программа анализа. Приставка имени каждого входного файла к «stats» кажется простой, поэтому она изменяет свой цикл, чтобы сделать это:

```
$ for datafile in NENE*[AB].txt
> do
>     echo $datafile stats-$datafile
> done

```

```
NENE01729A.txt stats-NENE01729A.txt
NENE01729B.txt stats-NENE01729B.txt
NENE01736A.txt stats-NENE01736A.txt
...
NENE02043A.txt stats-NENE02043A.txt
NENE02043B.txt stats-NENE02043B.txt

```

На самом деле она еще не запускалась `goostats` , но теперь она уверена, что сможет выбрать правильные файлы и сгенерировать правильные выходные имена файлов.

Впрочем, набирать команды снова и снова становится утомительно, и Нелле беспокоится из\-за ошибок, поэтому вместо повторного входа в цикл она нажимает стрелку вверх. В ответ оболочка заново отображает весь цикл на одной строке (используя точки с запятой для разделения частей):

```
$ for datafile in NENE*[AB].txt; do echo $datafile stats-$datafile; done

```

Используя клавишу со стрелкой влево, Nelle выполняет резервное копирование и изменяет команду `echo` на `bash goostats` :

```
$ for datafile in NENE*[AB].txt; do bash goostats $datafile stats-$datafile; done

```

Когда она нажимает Enter , оболочка запускает измененную команду. Однако, похоже, ничего не происходит \- нет вывода. Через некоторое время Нелл понимает, что, поскольку ее сценарий больше ничего не выводит на экран, она понятия не имеет, выполняется ли он, и тем более как быстро. Она убивает текущую команду, печатая `Ctrl-C` , использует стрелку вверх, чтобы повторить команду, и редактирует ее так:

```
$ for datafile in NENE*[AB].txt; do echo $datafile; bash goostats $datafile stats-$datafile; done

```

> ## Начало и конец
>
> Мы можем перейти к началу строки в оболочке, набрав `Ctrl-a` и до конца, используя `Ctrl-e` .

Когда она запускает свою программу сейчас, она выдает одну строку вывода каждые пять секунд или около того:

```
NENE01729A.txt
NENE01729B.txt
NENE01736A.txt
...

```

1518 умножить на 5 секунд, разделенных на 60, говорит ей, что выполнение сценария займет около двух часов. В качестве окончательной проверки она открывает другое окно терминала, входит в него `north-pacific-gyre/2012-07-03` и использует `cat stats-NENE01729B.txt` для проверки один из выходных файлов. Это выглядит хорошо, поэтому она решает выпить кофе и наверстать упущенное.

> ## Те, кто знает историю, могут ее повторить
>
> Другой способ повторить предыдущую работу \- использовать `history` команду, чтобы получить список последних нескольких сотен команд, которые были выполнены, а затем использовать `!123` (где «123» заменяется номером команды), чтобы повторить одну из этих команд. Например, если Nelle напечатает это:
>
> ```
> $ history | tail -n 5
>
> ```
>
> ```
>   456  ls -l NENE0*.txt
>   457  rm stats-NENE01729B.txt.txt
>   458  bash goostats NENE01729B.txt stats-NENE01729B.txt
>   459  ls -l NENE0*.txt
>   460  history
>
> ```
>
> то она может повторно запустить `goostats` на `NENE01729B.txt` просто набрав `!458` .

> ## Другие команды истории
>
> Есть несколько других команд быстрого доступа к истории.
>
> *   `Ctrl-R` входит в режим поиска в истории 'reverse\-i\-search' и находит самую последнюю команду в вашей истории, которая соответствует тексту, который вы вводите следующим. Нажмите `Ctrl-R` один или несколько дополнительных раз, чтобы найти более ранние совпадения.
> *   `!!` извлекает непосредственно предшествующую команду (вы можете или не можете найти это более удобным, чем использование стрелки вверх)
> *   `!$` получает последнее слово последней команды. Это полезно чаще, чем вы ожидаете: после `bash goostats NENE01729B.txt stats-NENE01729B.txt` , вы можете напечатать, `less !$` чтобы посмотреть на файл `stats-NENE01729B.txt` , что быстрее, чем стрелка вверх и редактирование командной строки.

> ## Делать пробный пробег
>
> Цикл \- это способ сделать много вещей одновременно \- или сделать много ошибок одновременно, если он делает неправильные вещи. Один из способов проверить, что *будет* делать цикл , \- `echo` это команды, которые он будет запускать, вместо того, чтобы фактически запускать их.
>
> Предположим, мы хотим предварительно просмотреть команды, которые будет выполнять следующий цикл, фактически не выполняя эти команды:
>
> ```
> $ for file in *.pdb
> > do
> >   analyze $file > analyzed-$file
> > done
>
> ```
>
> В чем разница между двумя циклами ниже, и какой из них мы хотим запустить?
>
> ```
> # Version 1
> $ for file in *.pdb
> > do
> >   echo analyze $file > analyzed-$file
> > done
>
> ```
>
> ```
> # Version 2
> $ for file in *.pdb
> > do
> >   echo "analyze $file > analyzed-$file"
> > done
>
> ```
>
> > ## Решение
> >
> > Вторая версия \- это та, которую мы хотим запустить. Это выводит на экран все, что заключено в кавычки, расширяя имя переменной цикла, потому что мы поставили перед ним знак доллара.
> >
> > Первая версия перенаправляет вывод команды `echo analyze $file` в файл, `analyzed-$file` . Создается серия файлов: `analyzed-cubane.pdb` и `analyzed-ethane.pdb` т. Д.
> >
> > Попробуйте обе версии для себя, чтобы увидеть результат! Обязательно откройте `analyzed-*.pdb` файлы, чтобы просмотреть их содержимое.

> ## Вложенные циклы
>
> Предположим, мы хотим создать структуру каталогов, чтобы организовать эксперименты по измерению констант скорости реакции с различными соединениями *и* разными температурами. Что будет результатом следующего кода:
>
> ```
> $ for species in cubane ethane methane
> > do
> >     for temperature in 25 30 37 40
> >     do
> >         mkdir $species-$temperature
> >     done
> > done
>
> ```
>
> > ## Решение
> >
> > У нас есть вложенный цикл, то есть содержащийся в другом цикле, поэтому для каждого вида во внешнем цикле внутренний цикл (вложенный цикл) выполняет итерацию по списку температур и создает новый каталог для каждой комбинации.
> >
> > Попробуйте запустить код для себя, чтобы увидеть, какие каталоги созданы!

> ## Ключевые моменты
>
> *   `for` Цикл повторяется команды один раз для каждой вещи в списке.
>
> *   Каждому `for` циклу нужна переменная для ссылки на то, над чем он работает в данный момент.
>
> *   Используйте, `$name` чтобы раскрыть переменную (т.е. получить ее значение). `${name}` также может быть использован.
>
> *   Не используйте пробелы, кавычки или символы подстановки, такие как «\*» или «?» в именах файлов, так как это усложняет расширение переменных.
>
> *   Присвойте файлам непротиворечивые имена, которые легко сопоставлять с шаблонами подстановочных знаков, чтобы упростить их выбор для зацикливания.
>
> *   Используйте клавишу со стрелкой вверх для прокрутки вверх по предыдущим командам, чтобы редактировать и повторить их.
>
> *   Используйте `Ctrl-R` для поиска по ранее введенным командам.
>
> *   Используйте `history` для отображения последних команд и `!number` для повторения команды по номеру.
>
