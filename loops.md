# Для циклов чтения и чтения в Bash
http://www.compciv.org/topics/bash/loops/

Как зацикливаться, то есть разрабатывать программу, чтобы сделать для вас повторяющуюся работу

Цикл является одной из наиболее фундаментальных и мощных конструкций в вычислениях, поскольку он позволяет нам повторять набор команд столько раз, сколько мы хотим, для списка элементов по нашему выбору. Большая часть вычислительного мышления включает в себя выполнение одной задачи и ее решение таким образом, чтобы ее можно было неоднократно применять ко всем другим аналогичным задачам, и цикл for \- это то, как мы заставляем компьютер выполнять эту повторяющуюся работу:

```
for item in $items
do
  task $item
done

```

В отличие от большей части кода, который мы уже написали в интерактивном режиме, цикл for не выполняется, как только мы нажимаем **Enter** :

```
user@host:~$ for item in $items

```

Мы можем написать, как многие команды , как мы хотим , чтобы в **блоке** между `do` и `done` ключевыми словами:

```
do
  command_1
  command_2
  # another for loop just for fun
  for a in $things; do; command_3 a; done
  command_4
done

```

Только пока мы не дойдем `done` и не нажмем **Enter** , цикл for выполнит свою работу.

Это в корне отличается от построчной команды и ответа, которые мы испытывали до сих пор в приглашении. И это предвещает, как мы будем программировать дальше: меньше внимания уделяется выполнению команд с каждой строкой и больше внимания *планированию* функциональности программы, а затем ее *выполнению* позже.

## Основной синтаксис

Синтаксис для `for` циклов может сбивать с толку, поэтому вот несколько основных примеров, чтобы подготовить / обновить ваше понимание их:

```
for animal in dog cat 'fruit bat' elephant ostrich
do
  echo "I want a $animal for a pet"
done

```

Вот более сложная версия с использованием переменных:

```
for thing in $collection_of_things
do
  some_program $thing
  another_program $thing >> data.txt
  # as many commands as we want
done

```

Подстановка команд может использоваться для генерации элементов, по которым проходит `for` цикл:

```
for var_name in $(seq 1 100); do
  echo "Counting $var_name..."
done

```

Если вам нужно прочитать список строк из файла, и вы абсолютно уверены, что ни одна из строк не содержит внутри них пробела:

```
for url in $(cat list_of_urls.txt); do
  curl "$url" >> everywebpage_combined.html
done

```

Цикл **read\-** while является разновидностью вышеописанного, но безопаснее для чтения строк из файла:

```
while read url
do
  curl "$url" >> everywebpage_combined.html
done < list_of_urls.txt

```

## Построение базового цикла for

Давайте начнем с самого начала, с очень минимального `for` цикла, а затем встроим его во что\-то более сложное, чтобы помочь нам понять их цель.

#### Самый простой цикл

Это примерно так же просто, как вы можете сделать цикл **for** :

```
user@host:~$ for x in 1
> do
> echo Hi
> done
Hi

```

Это казалось довольно бесполезным? Да, это должно быть. Я написал четыре строки кода, чтобы сделать то, что требуется одной строкой `echo 'Hi'` .

#### Больше элементов в коллекции

Трудно сказать, но «цикл» все\-таки выполнил. Это только что выполнено *один раз* . Хорошо, как мы можем заставить его выполняться более одного раза? Добавьте больше (разделенных пробелами) элементов справа от `in` ключевого слова. Давайте добавим еще четыре `1` :

```
user@host:~$ for x in 1 1 1 1
> do
> echo Hi
> done
Hi
Hi
Hi
Hi

```

Хорошо, не очень захватывающе, но программа определенно показалась по крайней мере *зацикленной* : четыре `1` привели к выполнению четырех `echo` команд.

Что произойдет, когда мы заменим эти четыре `1` числа другими? А может пара слов?

```
user@host:~$ for x in Q Zebra 999 Smithsonian
> do
> echo Hi
> done
Hi
Hi
Hi
Hi

```

И ... *ничего* . Таким образом, *цикл* автоматически не *делает* ничего *конкретного* для набора значений, который мы ему дали. Во всяком случае, пока.

#### Обратитесь к переменной цикла

Давайте посмотрим *слева* от `in` ключевого слова, и на этом `x` . Какой в ​​этом смысл `x` ? Строчные буквы `x` \- это не имя ключевого слова или команды, с которыми мы сталкивались до сих пор (и выполнение их самостоятельно в командной строке вызовет ошибку). Так может это переменная? Давайте попробуем сослаться на это в `echo` утверждении:

```
user@host:~$ for x in Q Zebra 999 Smithsonian
> do
> echo Hi $x
> done
Hi Q
Hi Zebra
Hi 999
Hi Smithsonian

```

Бинго. Это в значительной степени фундаментальная работа `for` цикла: \- Получить коллекцию элементов / значений ( `Q Zebra 999 Smithsonian` ) \- Передать их в `for` конструкцию цикла \- Используя переменную цикла ( `x` ) в качестве заполнителя, написать команды между блоком `do` / `done` . \- Когда выполнение цикла, переменная цикла, `x` , принимает значение каждого из элементов в списке \- `Q` , `Zebra` , `999` , `Smithsonian` , \- и блок команд между `do` и `done` затем выполняется. Эта последовательность повторяется один раз для каждого элемента в списке.

Блок `do` / `done` может содержать любую последовательность команд, даже другую `for` \-loop:

```
user@host:~$ for x in Q Zebra 999 Smithsonian
> do
> echo Hi
> done
Hi Q
Hi Zebra
Hi 999
Hi Smithsonian

```

```
user@host:~$ for x in $(seq 1 3); do
>   for y in A B C; do
>     echo "$x:$y"
>   done
> done
1:A
1:B
1:C
2:A
2:B
2:C
3:A
3:B
3:C

```

Циклы внутри цикла \- это общая конструкция в программировании. По большей части я попытаюсь избежать назначения проблем, связанных с такой логикой, так как это может быть сложно раскрутить во время отладки.

### Прочитайте файл, построчно, надежно с read\-while

Поскольку `cat` файл печатается построчно, следующий цикл for кажется разумным:

```
user@host:~$ for line in $(cat list-of-dirs.txt)
> do
>    echo "$line"
> done

```

Однако подстановка команды приведет `cat` к разбивке слов по пробелам. Если `list-of-dirs.txt` содержит следующее:

```
Apples
Oranges
Documents and Settings

```

Вывод `for` цикла будет таким:

```
Apples
Oranges
Documents
and
Settings

```

Цикл **read\-** while сохранит слова в строке:

```
user@host:~$ while read line
  do
      echo "$line"
  done < list-of-dirs.txt
Apples
Oranges
Documents and Settings

```

Мы также можем передать из результата команды, заключив ее в `<(` и `)` :

```
user@host:~$ while read line
  do
      echo "Word count per line: $line"
  done < <(cat list-of-dirs.txt | wc -w)
1
1
3

```

## Трубы и петли

Если вы пришли с других языков, потоки данных могут быть вам незнакомы. По крайней мере, они для меня, поскольку синтаксис для работы с ними гораздо более прямой и прямой в Bash, чем в Ruby или Python.

Однако, если вы новичок в программировании на любом языке, также может быть неясно, насколько работа с потоками данных отличается от работы с циклами.

Например, следующий фрагмент:

```
user@host:~$ echo "hello world i am here" | \
>                   tr '[:lower:]' '[:upper:]' | tr ' ' '\n'
HELLO
WORLD
I
AM
HERE

```

\- производит тот же вывод, что и этот цикл:

```
for word in hello world i am here; do
  echo $word | tr '[:lower:]' '[:upper:]'
done

```

И в зависимости от вашей мысленной модели вещей, действительно кажется , что в обоих примерах, каждое слово, например `hello` , `world` , пропускают через процесс перевода (через `tr` ) , а затем повторил.

### Трубы и фильтры

Не вдаваясь в основы системы Unix, в которой канал работает принципиально иначе, чем цикл, позвольте мне предложить обходной путь:

Программы, которые передают из stdin и stdout, обычно могут быть упорядочены как фильтры, в которых поток данных поступает в программу и выходит в другом формате:

```
# send the stream through a reverse filter
user@host:~$ echo "hello world i am here" | rev
ereh ma i dlrow olleh

# filter out the first 2 characters
user@host:~$ echo "hello world i am here" | cut -c 3-
llo world i am here

# filter out the spaces
user@host:~$ echo "hello world i am here" | tr -d ' '
helloworldiamhere

# filter out words with less than 4 characters
user@host:~$ echo "hello world i am here" | grep -oE '[a-z]{4,}'
hello
world
here

```

Для задач, которые представляют собой нечто большее, чем просто преобразование данных из фильтра в фильтр, подумайте об использовании цикла. Что может быть такой задачей? Получив список URL\-адресов, загрузите каждый из них и отправьте по электронной почте загруженные данные с настроенным телом и темой:

```
user@host:~$ while read url; do
   # download the page
   content=$(curl -Ls $url)
   # count the words
   num_of_words=$(echo $content | wc -w)
   # extract the title
   title=$(echo $content | grep -oP '(?<=<title>)[^<]+')
   # send an email with the page's title and word count
   echo "$content" | mail whoever@stanford.edu -s "$title: $num_of_words words"
   echo "...Sending: $title: $num_of_words words"
done < urls.txt

```

Источник ввода данных, каждый URL\-адрес `urls.txt` , здесь не *фильтруется* . Вместо этого для каждого URL выполняется многошаговая задача.

### Трубка в чтении

Тем не менее, сам цикл может быть реализован как еще один фильтр среди фильтров. Возьмем эту вариацию цикла read\-while, в котором результат `echo | grep` строки, строка за строкой, передается по конвейеру в `while` цикл, который печатается в стандартный вывод `echo` , который перенаправляется в файл с именем some.txt:

```
echo 'hey you' | grep -oE '[a-z]+' | while read line;
  do
  echo word | wc -c
done >> sometxt

```

Это не та конструкция, которую вам, возможно, придется делать часто, если она вообще нужна, но, надеюсь, она укрепляет использование каналов в Unix.

## Меньше интерактивного программирования

Частое использование `for` циклов и подобных конструкций означает, что мы перешли хорошие времена ввода одной строки команд и выполнили ее сразу после нажатия **Enter** . Независимо от того, сколько команд мы упаковываем внутри `for` цикла, ничего не произойдет, пока мы не найдем `done` ключевое слово

#### Напиши один раз. Затем зациклить

С потерей линейного взаимодействия с оболочкой мы теряем главное преимущество интерактивного приглашения: немедленную обратную связь. И у нас все еще есть все недостатки: если мы сделаем опечатку раньше в **блоке** команд между `do` и `done` , мы должны начать все сначала.

Вот как мы можем это смягчить:

##### Проверьте свой код, один случай за раз

Одна из самых больших ошибок, которую делают новички с `for` циклами, \- они думают, что `for` цикл *немедленно* решает их проблему. Таким образом, если им нужно загрузить 10000 URL\-адресов, но они не могут правильно загрузить только *один* URL\-адрес, они считают, что помещение своих некорректных команд в `for` цикл является шагом в правильном направлении.

Помимо того, что это принципиально неправильное понимание `for` цикла, практическая проблема заключается в том, что вы сейчас выполняете свой неработающий код *10 000* раз, а это значит, что вам придется ждать в *10 000* раз больше, чтобы узнать, что ваш код, увы, все еще не работает.

Так притворись, что никогда не слышал о `for` петлях. Представьте, что вам нужно загрузить все 10000 URL\-адресов, по одной команде за раз. Можете ли вы написать команду, чтобы сделать это для первого URL. Как насчет второго? Если вы достаточно уверены в том, что никакие незначительные синтаксические ошибки не приводят вас в замешательство , *то* пришло время подумать о том, как найти общий шаблон для 9997 других URL\-адресов.

##### Писать сценарии

Интерактивная командная строка великолепна. Начать было весело, и это будет весело на протяжении всей вашей компьютерной карьеры. Но когда перед вами стоит большая задача, включающая более десяти строк кода, тогда самое время поместить этот код в сценарий оболочки. Не доверяйте своим ошибочным человеческим пальцам безошибочно перепечатывать код.

![IMG](http://www.compciv.org/files/images/topics/unix/nano-for.png)

Используйте **nano** для работы с циклами и [сохраните их как сценарии оболочки](http://www.compciv.org/topics/bash/scripting) . Для более длинных файлов я буду работать в текстовом редакторе моего компьютера ( [Sublime Text](http://www.sublimetext.com/) ), а затем загружать на сервер.

### Упражнение с веб\-соскоб

Просто чтобы обосновать синтаксис и работу цикла **for** , вот мыслительный процесс от превращения рутинной задачи в цикл:

> Для чисел от 1 до 10 используйте **curl,** чтобы загрузить запись в Википедии для каждого номера и сохранить ее в файл с именем " `wiki-number-(whatever the number is).html` "

#### Старомодный способ

С помощью всего лишь 10 URL \- адресов, мы *могли бы* установить несколько переменных , а затем скопировать и вставить **завиток** команду, в 10 раз, внесение изменений в каждой строке:

```
user@host:~$ curl http://en.wikipedia.org/wiki/1 > 'wiki-number-1.html'
user@host:~$ curl http://en.wikipedia.org/wiki/2 > 'wiki-number-2.html'
user@host:~$ curl http://en.wikipedia.org/wiki/3 > 'wiki-number-3.html'
user@host:~$ curl http://en.wikipedia.org/wiki/4 > 'wiki-number-4.html'
user@host:~$ curl http://en.wikipedia.org/wiki/5 > 'wiki-number-5.html'
user@host:~$ curl http://en.wikipedia.org/wiki/6 > 'wiki-number-6.html'
user@host:~$ curl http://en.wikipedia.org/wiki/7 > 'wiki-number-7.html'
user@host:~$ curl http://en.wikipedia.org/wiki/8 > 'wiki-number-8.html'
user@host:~$ curl http://en.wikipedia.org/wiki/9 > 'wiki-number-9.html'
user@host:~$ curl http://en.wikipedia.org/wiki/10 > 'wiki-number-10.html'

```

И угадайте, что? Это *работает* . Для 10 URL\-адресов это не плохое решение, и это значительно быстрее, чем делать это *старым* старомодным способом (делать это из веб\-браузера)

#### Сокращение повторения

Даже не задумываясь о цикле, мы все равно можем уменьшить повторение, используя **переменные** : базовый URL `http://en.wikipedia.org/wiki/` и базовое имя файла никогда не меняются, поэтому давайте присвоим эти значения переменным, которые можно использовать повторно:

```
user@host:~$ base_url=http://en.wikipedia.org/wiki
user@host:~$ fname='wiki-number'
user@host:~$ curl "$base_url/1" > "$fname-1"
user@host:~$ curl "$base_url/2" > "$fname-2"
user@host:~$ curl "$base_url/3" > "$fname-3"
user@host:~$ curl "$base_url/4" > "$fname-4"
user@host:~$ curl "$base_url/5" > "$fname-5"
user@host:~$ curl "$base_url/6" > "$fname-6"
user@host:~$ curl "$base_url/7" > "$fname-7"
user@host:~$ curl "$base_url/8" > "$fname-8"
user@host:~$ curl "$base_url/9" > "$fname-9"
user@host:~$ curl "$base_url/10" > "$fname-10"

```

#### Применяя цикл for

К этому моменту мы упростили шаблон до тех пор, пока не увидим, как мало меняется с каждой отдельной задачей. Узнав о параметре `for` \-loop, мы можем применить его, не задумываясь (мы также добавили команду **сна,** чтобы сделать паузу между веб\-запросами)

```
user@host:~$ base_url=http://en.wikipedia.org/wiki
user@host:~$ fname='wiki-number'
user@host:~$ for x in 1 2 3 4 5 6 7 8 9 10
> do
>    curl "$base_url/$x" > "$fname-$x"
>    sleep 2
> done

```

#### Генерация списка

В большинстве ситуаций создать цикл for легко; это *создание списка,* который может быть тяжелой работой. Что если мы хотим собрать страницы для номеров от 1 до 100? Это много печатать.

Но если мы позволим нашей лени диктовать наше мышление, мы можем представить, что подсчет от *x* до *y* кажется неотъемлемой вычислительной задачей. И это так, и в Unix есть `seq` утилита для этого:

```
user@host:~$ base_url=http://en.wikipedia.org/wiki
user@host:~$ fname='wiki-number'
user@host:~$ for x in $(seq 1 100)
> do
>    curl "$base_url/$x" > "wiki-number-$x"
>    sleep 2
> done

```

#### Генерация списка не чисел для итерации

Многие повторяющиеся задачи не так просты, как подсчет от *x* до *y* , и поэтому возникает проблема, *как создать нелинейный список элементов* ? Это в основном то, что искусство сбора данных и управления. Но давайте сделаем простой сценарий для себя:

> Для десяти из десятибуквенных (или более) слов, которые хотя бы один раз появляются в заголовке на текущей главной странице NYTimes.com, извлеките страницу Викисловаря для этого слова.

Мы разбиваем эту задачу на две части:

1.  Получить список из десяти слов с 10 + буквами из заголовков nytimes.com
2.  Передайте эти слова нашему циклу for

Шаг 1: Использование утилиты **pup** (или HTML\-анализатора командной строки по вашему выбору):

```
user@host:~$ words=$(curl -s http://www.nytimes.com | \
>  pup 'h2.story-heading text{}' | \
>  grep -oE '[[:alpha:]]{10,}' | sort | \
>  uniq | head -n 10)

```

Шаг 2 (при условии, что `words` переменная передается вместе):

```
user@host:~$ base_url='https://en.wiktionary.org/wiki/'
user@host:~$ fname='wiktionary-'
user@host:~$ for word in $words
> do
>    echo $word
>    curl -sL "$base_url$word" > "$fname$word.html"
>    sleep 2
> done
```
